/*
 * File: Forward_kinematics_v1.c
 *
 * MATLAB Coder version            : 4.3
 * C/C++ source code generated on  : 01-Apr-2020 16:21:00
 */

/* Include Files */
#include "Forward_kinematics_v1.h"
#include "Forward_kinematics_v1_data.h"
#include "Forward_kinematics_v1_initialize.h"
#include "H_leg.h"
#include "Inverse_kinematics.h"
#include "fmincon.h"
#include "rt_defines.h"
#include "rt_nonfinite.h"
#include <math.h>

/* Function Declarations */
static double rt_atan2d_snf(double u0, double u1);

/* Function Definitions */

/*
 * Arguments    : double u0
 *                double u1
 * Return Type  : double
 */
static double rt_atan2d_snf(double u0, double u1)
{
  double y;
  int b_u0;
  int b_u1;
  if (rtIsNaN(u0) || rtIsNaN(u1)) {
    y = rtNaN;
  } else if (rtIsInf(u0) && rtIsInf(u1)) {
    if (u0 > 0.0) {
      b_u0 = 1;
    } else {
      b_u0 = -1;
    }

    if (u1 > 0.0) {
      b_u1 = 1;
    } else {
      b_u1 = -1;
    }

    y = atan2(b_u0, b_u1);
  } else if (u1 == 0.0) {
    if (u0 > 0.0) {
      y = RT_PI / 2.0;
    } else if (u0 < 0.0) {
      y = -(RT_PI / 2.0);
    } else {
      y = 0.0;
    }
  } else {
    y = atan2(u0, u1);
  }

  return y;
}

/*
 * Arguments    : const double system_parameters[5]
 *                const double q[3]
 *                double phi[3]
 * Return Type  : void
 */
void Forward_kinematics_v1(const double system_parameters[5], const double q[3],
  double phi[3])
{
  int i;
  double t2_tmp;
  double x0[6];
  double t3_tmp;
  double t4_tmp;
  double t9_tmp;
  double t10_tmp;
  double t11_tmp;
  double q_1_tmp_tmp;
  double b_q_1_tmp_tmp;
  double c_q_1_tmp_tmp;
  double d_q_1_tmp_tmp;
  double q_1_tmp_tmp_tmp;
  double e_q_1_tmp_tmp;
  double b_q_1_tmp_tmp_tmp;
  double q_1_tmp;
  double f_q_1_tmp_tmp;
  double b_q_1_tmp;
  double x[6];
  int b_i;
  double q_1[3];
  int i1;
  double H_1[16];
  double b_q_1;
  double dv[16];
  double t5_tmp;
  double t12_tmp;
  double t74;
  double t67;
  double t77;
  double t17;
  double c_q_1_tmp_tmp_tmp;
  double t19;
  double d_q_1_tmp_tmp_tmp;
  double t23;
  double e_q_1_tmp_tmp_tmp;
  double f_q_1_tmp_tmp_tmp;
  double t51;
  double q_2;
  double c_q_1_tmp;
  double d_q_1_tmp;
  double e_q_1_tmp;
  double f_q_1_tmp;
  double g_q_1_tmp;
  double h_q_1_tmp;
  double c_q_1[2];
  int loop_ub;
  if (isInitialized_Forward_kinematics_v1 == false) {
    Forward_kinematics_v1_initialize();
  }

  for (i = 0; i < 6; i++) {
    x0[i] = 0.0;
  }

  t2_tmp = cos(system_parameters[2]);
  t3_tmp = cos(system_parameters[0]);
  t4_tmp = cos(system_parameters[1]);
  t9_tmp = sin(system_parameters[2]);
  t10_tmp = sin(system_parameters[0]);
  t11_tmp = sin(system_parameters[1]);
  q_1_tmp_tmp = t2_tmp * t4_tmp;
  b_q_1_tmp_tmp = t3_tmp * t4_tmp;
  c_q_1_tmp_tmp = t2_tmp * t3_tmp;
  d_q_1_tmp_tmp = t2_tmp * t10_tmp * t11_tmp;
  q_1_tmp_tmp_tmp = t3_tmp * t9_tmp;
  e_q_1_tmp_tmp = q_1_tmp_tmp_tmp * t11_tmp;
  b_q_1_tmp_tmp_tmp = t9_tmp * t10_tmp;
  q_1_tmp = t11_tmp * 0.0 * 0.0;
  f_q_1_tmp_tmp = cos(system_parameters[3]);
  b_q_1_tmp = t4_tmp * t9_tmp * t10_tmp;
  for (i = 0; i < 3; i++) {
    b_i = i << 1;
    i1 = (i + 1) << 1;
    if (b_i + 1 > i1) {
      b_i = 0;
      i1 = 0;
    }

    b_q_1 = (((double)i + 1.0) - 1.0) * 2.0 / 3.0 * 3.1415926535897931;

    /*  Step 1: Find the theta angle without translation part */
    /*  Compute each angles of joints in legs in PSM */
    /*  phi_ee=[phi_1; phi_2; phi_3] - Angles in XYZ Euler angles parametrization */
    /*  system_parameters=[beta_1; beta_2; alpha_1; alpha_2, system_radius] - Parameters of PSM */
    /*  Created by Valeria Skvo */
    /* A_Q1 */
    /*     A_THETA = A_Q1(ETA_I,IN2,IN3) */
    /*     This function was generated by the Symbolic Math Toolbox version 8.4. */
    /*     31-Mar-2020 18:21:33 */
    t5_tmp = cos(b_q_1);
    t12_tmp = sin(b_q_1);
    b_q_1 = t5_tmp * t5_tmp;

    /* B_Q1 */
    /*     B_THETA = B_Q1(ETA_I,IN2,IN3) */
    /*     This function was generated by the Symbolic Math Toolbox version 8.4. */
    /*     31-Mar-2020 18:21:34 */
    /* C_Q1 */
    /*     C_THETA = C_Q1(ETA_I,IN2,IN3) */
    /*     This function was generated by the Symbolic Math Toolbox version 8.4. */
    /*     31-Mar-2020 18:21:35 */
    t74 = d_q_1_tmp_tmp * b_q_1;
    t67 = e_q_1_tmp_tmp * b_q_1;
    t77 = c_q_1_tmp_tmp * t5_tmp * t11_tmp * 0.0;
    t17 = c_q_1_tmp_tmp * t11_tmp * t12_tmp * 0.0;
    c_q_1_tmp_tmp_tmp = t2_tmp * t5_tmp;
    t19 = c_q_1_tmp_tmp_tmp * t10_tmp * t11_tmp * t12_tmp * 0.0;
    d_q_1_tmp_tmp_tmp = t3_tmp * t5_tmp;
    t23 = d_q_1_tmp_tmp_tmp * t9_tmp * t11_tmp * t12_tmp * 0.0;
    e_q_1_tmp_tmp_tmp = t5_tmp * t9_tmp;
    f_q_1_tmp_tmp_tmp = e_q_1_tmp_tmp_tmp * t10_tmp;
    t51 = f_q_1_tmp_tmp_tmp * t11_tmp * 0.0;
    q_2 = b_q_1_tmp_tmp_tmp * t11_tmp * t12_tmp * 0.0;
    c_q_1_tmp = t11_tmp * 0.0 * b_q_1;
    d_q_1_tmp = t5_tmp * t11_tmp * t12_tmp;
    e_q_1_tmp = d_q_1_tmp_tmp * b_q_1;
    f_q_1_tmp = e_q_1_tmp_tmp * b_q_1;
    g_q_1_tmp = c_q_1_tmp_tmp * t5_tmp * t11_tmp * 0.0;
    h_q_1_tmp = c_q_1_tmp_tmp * t11_tmp * t12_tmp * 0.0;
    b_q_1 = Inverse_kinematic_solver((((((((((((((((((((((((((((-f_q_1_tmp_tmp -
      c_q_1_tmp_tmp * t4_tmp) - b_q_1_tmp) + d_q_1_tmp_tmp) - e_q_1_tmp_tmp) +
      q_1_tmp_tmp * t10_tmp * t12_tmp * 0.0) - b_q_1_tmp_tmp * t9_tmp * t12_tmp *
      0.0) - q_1_tmp_tmp * t5_tmp * t10_tmp * 0.0) + b_q_1_tmp_tmp * t5_tmp *
      t9_tmp * 0.0) - t77) + t74) - t67) - t74) + t67) - t17 * 0.0) - t51) - q_2
      * 0.0) - t77 * 0.0) + t17) + t19) - t23) - t19) + t23) - t51 * 0.0) + q_2)
      - d_q_1_tmp_tmp * 0.0 * 0.0 * 0.0 * b_q_1) + e_q_1_tmp_tmp * 0.0 * 0.0 *
      0.0 * b_q_1) + t19 * 0.0) - t23 * 0.0, t9_tmp * (((((((((t4_tmp * t5_tmp *
      0.0 - t11_tmp * 0.0) + t4_tmp * t12_tmp * 0.0) - q_1_tmp) + c_q_1_tmp) -
      c_q_1_tmp) - d_q_1_tmp) + d_q_1_tmp) + q_1_tmp * b_q_1) + d_q_1_tmp * 0.0 *
      0.0 * 0.0) * 2.0, (((((((((((((((((((((((((((-f_q_1_tmp_tmp -
      c_q_1_tmp_tmp * t4_tmp) + b_q_1_tmp) + d_q_1_tmp_tmp) + e_q_1_tmp_tmp) +
      q_1_tmp_tmp * t10_tmp * t12_tmp * 0.0) + b_q_1_tmp_tmp * t9_tmp * t12_tmp *
      0.0) - q_1_tmp_tmp * t5_tmp * t10_tmp * 0.0) - b_q_1_tmp_tmp * t5_tmp *
      t9_tmp * 0.0) - g_q_1_tmp) + e_q_1_tmp) + f_q_1_tmp) - e_q_1_tmp) -
      f_q_1_tmp) - h_q_1_tmp * 0.0) + t51) + q_2 * 0.0) - g_q_1_tmp * 0.0) +
      h_q_1_tmp) + t19) + t23) - t19) - t23) + t51 * 0.0) - q_2) - d_q_1_tmp_tmp
      * 0.0 * 0.0 * 0.0 * b_q_1) - e_q_1_tmp_tmp * 0.0 * 0.0 * 0.0 * b_q_1) +
                         t19 * 0.0) + t23 * 0.0, 0.0);
    if (b_q_1 != rtInf) {
      /* A_Q2 */
      /*     A_MU_1 = A_Q2(ETA_I,IN2,IN3,Q_1) */
      /*     This function was generated by the Symbolic Math Toolbox version 8.4. */
      /*     31-Mar-2020 18:21:38 */
      e_q_1_tmp = cos(b_q_1);
      f_q_1_tmp = sin(system_parameters[3]);
      h_q_1_tmp = sin(b_q_1);

      /* B_Q2 */
      /*     B_MU_1 = B_Q2(ETA_I,IN2,IN3,Q_1) */
      /*     This function was generated by the Symbolic Math Toolbox version 8.4. */
      /*     31-Mar-2020 18:21:39 */
      /* C_Q2 */
      /*     C_MU_1 = C_Q2(ETA_I,IN2,IN3,Q_1) */
      /*     This function was generated by the Symbolic Math Toolbox version 8.4. */
      /*     31-Mar-2020 18:21:39 */
      q_2 = t2_tmp * f_q_1_tmp_tmp;
      c_q_1_tmp = f_q_1_tmp_tmp * t3_tmp;
      d_q_1_tmp = q_1_tmp_tmp_tmp * f_q_1_tmp;
      t77 = c_q_1_tmp_tmp_tmp * f_q_1_tmp * 0.0 * h_q_1_tmp;
      t17 = f_q_1_tmp_tmp * t5_tmp * t9_tmp * 0.0 * h_q_1_tmp;
      t19 = t9_tmp * f_q_1_tmp * t10_tmp * t12_tmp * 0.0;
      g_q_1_tmp = t2_tmp * e_q_1_tmp;
      t23 = g_q_1_tmp * f_q_1_tmp * t10_tmp;
      t51 = f_q_1_tmp_tmp * e_q_1_tmp * t9_tmp * t10_tmp;
      b_q_1 = e_q_1_tmp_tmp_tmp * f_q_1_tmp * t10_tmp * 0.0;
      t74 = t2_tmp * f_q_1_tmp * t12_tmp * 0.0 * h_q_1_tmp;
      t67 = f_q_1_tmp_tmp * t9_tmp * t12_tmp * 0.0 * h_q_1_tmp;
      c_q_1_tmp_tmp_tmp = e_q_1_tmp * t12_tmp;
      e_q_1_tmp_tmp_tmp = t5_tmp * e_q_1_tmp;
      q_2 = Inverse_kinematic_solver((((((((((((((((-t4_tmp - q_2 * t3_tmp) -
        d_q_1_tmp) + q_2 * t10_tmp * t12_tmp * 0.0) - t77) + t17) + t19) - q_2 *
        t5_tmp * t10_tmp * 0.0) - t23) + t51) - c_q_1_tmp_tmp * e_q_1_tmp *
        f_q_1_tmp * t12_tmp * 0.0) + c_q_1_tmp * e_q_1_tmp * t9_tmp * t12_tmp *
        0.0) - b_q_1) - t74) + t67) + c_q_1_tmp_tmp * t5_tmp * e_q_1_tmp *
        f_q_1_tmp * 0.0) - c_q_1_tmp * t5_tmp * e_q_1_tmp * t9_tmp * 0.0,
        f_q_1_tmp * ((((e_q_1_tmp_tmp_tmp * 0.0 + c_q_1_tmp_tmp_tmp * 0.0) -
                       t3_tmp * t12_tmp * 0.0 * h_q_1_tmp) - h_q_1_tmp * t10_tmp)
                     + d_q_1_tmp_tmp_tmp * 0.0 * h_q_1_tmp) * 2.0,
        (((((((((((((((-cos(system_parameters[1]) - q_2 * t3_tmp) + d_q_1_tmp) +
                     q_2 * t10_tmp * t12_tmp * 0.0) + t77) + t17) - t19) - q_2 *
                 t5_tmp * t10_tmp * 0.0) + t23) + t51) + c_q_1_tmp_tmp *
              e_q_1_tmp * f_q_1_tmp * t12_tmp * 0.0) + c_q_1_tmp * e_q_1_tmp *
             t9_tmp * t12_tmp * 0.0) + b_q_1) + t74) + t67) - c_q_1_tmp_tmp *
         t5_tmp * e_q_1_tmp * f_q_1_tmp * 0.0) - c_q_1_tmp * t5_tmp * e_q_1_tmp *
        t9_tmp * 0.0, 1.0);
      if (q_2 != rtInf) {
        /* Q3_FIND */
        /*     Q_3 = Q3_FIND(ETA_I,IN2,IN3,Q_1,Q_2) */
        /*     This function was generated by the Symbolic Math Toolbox version 8.4. */
        /*     31-Mar-2020 18:21:45 */
        b_q_1 = cos(q_2);
        t17 = sin(q_2);
        t19 = t5_tmp * h_q_1_tmp;
        t23 = t12_tmp * h_q_1_tmp;
        t51 = t5_tmp + t12_tmp * 0.0;
        t67 = b_q_1 * t10_tmp * h_q_1_tmp + t17 * (q_1_tmp_tmp_tmp + g_q_1_tmp *
          t10_tmp);
        t77 = b_q_1 * (e_q_1_tmp_tmp_tmp + -(t3_tmp * t23)) + t17 *
          (b_q_1_tmp_tmp_tmp * t12_tmp - t2_tmp * (t19 + t3_tmp *
            c_q_1_tmp_tmp_tmp));
        t74 = t5_tmp * 0.0 + -t12_tmp;
        b_q_1 = b_q_1 * (c_q_1_tmp_tmp_tmp + t3_tmp * t19) + -(t17 *
          (f_q_1_tmp_tmp_tmp + t2_tmp * (t23 + -(t3_tmp * e_q_1_tmp_tmp_tmp))));
        b_q_1 = acos(-1.0 / sqrt(t51 * t51 + t74 * t74) * ((t51 * t77 - t74 *
          b_q_1) + t67 * 0.0) / sqrt((t67 * t67 + b_q_1 * b_q_1) + t77 * t77)) +
          -3.1415926535897931;
      } else {
        b_q_1 = rtInf;
      }
    } else {
      q_2 = rtInf;
      b_q_1 = rtInf;
    }

    c_q_1[0] = q_2;
    c_q_1[1] = b_q_1;
    loop_ub = i1 - b_i;
    for (i1 = 0; i1 < loop_ub; i1++) {
      x0[b_i + i1] = c_q_1[i1];
    }
  }

  fmincon(system_parameters, q, x0, x);
  q_1[0] = q[0];
  q_1[1] = x[0];
  q_1[2] = x[1];
  H_leg(system_parameters, q_1, H_1);

  /* R_TO_EULXYZ */
  /*     PHI_EE = R_TO_EULXYZ(IN1) */
  /*     This function was generated by the Symbolic Math Toolbox version 8.4. */
  /*     01-Apr-2020 11:15:58 */
  q_1[0] = q[0];
  q_1[1] = x[0];
  q_1[2] = x[1];
  phi[0] = -rt_atan2d_snf(H_1[9], H_1[10]);
  H_leg(system_parameters, q_1, dv);
  phi[1] = asin(dv[8]);
  phi[2] = -rt_atan2d_snf(H_1[4], H_1[0]);
}

/*
 * File trailer for Forward_kinematics_v1.c
 *
 * [EOF]
 */
